var voterClient = function() {
var exports = {};
//////////////////////////////////////////////////////////////////////////////////////////////

var crypto = require('./cryptofunc');
var strHexConversion = require('./strHexConversion');
var unpair = crypto.deconcatenate;
var verif = crypto.verifsig;


// SHORTCUTS

var pair = crypto.concatenate;
var enc  = crypto.pke_encrypt;
var dec  = crypto.pke_decrypt;

// TAGS (in hex encoding)

exports.TAG_ACCEPTED = "00";
exports.TAG_BALLOTS = '01';

// Returns a new voter client instance
exports.create = function(electionID, colServVerifKey, mixServEncKeys, mixServVerifKeys)
{
    ///
    // Method createBallot
    //
    // Returns
	//  	ENC_mix1(electionID, ENC_Mix2( electionID, ... Enc_MixN(electionID, userCode, receiptID, choiceMsg)...)
    //
    // Arguments:
    //	int      	choice
	//	string		userCode	
    //
    // Returns:
    //   a receipt
    //
    function createBallot (choice, userCode) {
        // TODO choice now is an integer. It coule be an arbitrary message
        var choiceMsg = crypto.int32ToHexString(choice);
        var N = mixServEncKeys.length; // the number of mix servers
        var ciphertexts = new Array(N+1); // array with the chain of ciphertexts
        var randomCoins = new Array(N); // array with the used random coins

        
        var userCodeHex = strHexConversion.hexEncode(userCode);
        // concatenate the randomCode provided by the voter with a receipt id randomly generated 
        var receiptID =  crypto.nonce().slice(0,8); 
        // The input of crypto.concatenate must be an even number of characters
        // Because its input is supposed to be hex encoded bytes
        // (1 byte = 2 hex digits)

        
        // create the inner-most message (userCode, receiptID, choice)
        ciphertexts[N] = pair(electionID, pair(userCodeHex, pair(receiptID, choiceMsg)));

        // encrypt the message for the chain of mix servers
        for (var i=N-1; i>=0; --i) {
            var r = crypto.pke_generateEncryprionCoins();
        	ciphertexts[i] = enc(mixServEncKeys[i], pair(electionID, ciphertexts[i+1]), r);
            randomCoins[i] = r;
        }

        ballot = ciphertexts[0];

        return { electionID: electionID, 
                 ballot: ballot, 
                 choice: choice, 
                 userCode: userCode,
                 receiptID: receiptID, 
                 ciphertexts: ciphertexts,
                 randomCoins: randomCoins};
    }


    ///
    // Method validateReceipt
    //
    // Returns true if the given receipt is valid 
    //
    function validateReceipt (receipt) {
        // check if there is no mismatch of election ids
        if (electionID !== receipt.electionID) return false;
        // check the signature
        message = pair(exports.TAG_ACCEPTED, pair(electionID, receipt.ballot));
        return crypto.verifsig(colServVerifKey, message, receipt.signature); 
    }


    ///
    // Check the result of the collectin server against the given
    // receipt.
    //
    function checkColServerResult(data, receipt) {
        var res = validServerOutput(receipt.ciphertexts[0], data, colServVerifKey);
        if (res.blame) { 
            // We need to add the blaming info to res.
            // In this case it is the signature of the collecting
            // server and expected ballot:
            //
            res.blamingData = {
                electionID: receipt.electionID, 
                signature: receipt.signature, // the signature of the collecting server
                ballot: receipt.ballot // the ballot signed by the collecting server (==ciphertexts[0])
            }
        }
        return res;
    }

    ///
    // Check the result of the mix server with the given index
    // against the given receipt.
    //
    function checkMixServerResult(i, data, receipt) {
        var res = validServerOutput(receipt.ciphertexts[i+1], data, mixServVerifKeys[i]);
        if (res.blame) { 
            // We need to add the blaming info to res.
            // In this case it input ciphertext (our ciphertex in
            // the output of the previous mix server) and the
            // missing ciphertext (not found in the output)
            //
            res.blamingData = {
                electionID: receipt.electionID, 
                mixServer: i,
                mixServerEncKey: mixServEncKeys[i],
                previousCiphertext: receipt.ciphertexts[i],
                missingCiphertext:  receipt.ciphertexts[i+1],
                encryptionRandomness: receipt.randomCoins[i]
            }
        }
        return res;
    }


    // PRIVATE METHODS
    
    function validServerOutput(item, data, verificationKey) {
		var p = unpair(data);
		data = p.first; // tag,elID,...
		var signature = p.second;
        // check the signature
        if (!verif(verificationKey, data, signature)) 
            return {ok:false, blame:false, descr:'Wrong signature'};
       
        data = crypto.splitter(data);

		if (data.nextMessage() !== exports.TAG_BALLOTS) // expected the tag
            return {ok:false, blame:false, descr:'Wrong tag'};

        var x = data.nextMessage();
        if (x !== electionID)  // expected the election id
        {
            return {ok:false, blame:false, descr:'Wrong election ID'};
        }

        // The rest of data is a list of ballots. 
        // Make sure that item is on this list.
        for (var i=0; !data.empty(); ++i) {
            if (item === data.nextMessage())
                return {ok:true, blame:false, descr:"Everything is fine"};
        }

        blamingData = {}
        return {ok:false, blame:true, descr:"Ballot not found"};
    }

    return { createBallot: createBallot, 
             validateReceipt: validateReceipt,
             checkColServerResult: checkColServerResult,
             checkMixServerResult: checkMixServerResult };
}

//////////////////////////////////////////////////////////////////////////////////////////////
return exports;
}();

if (typeof(module)!=='undefined' && module.exports) {
    module.exports = voterClient;
}

