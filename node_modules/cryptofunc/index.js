var cryptofunc = function() {
var exports = {};
//////////////////////////////////////////////////////////////////////////////////////////////

var forge = require('node-forge');

// All the input (arguments) and output (returned values) of
// functions defined in this module are (assumed to be)
// hex-encoded.

//////////////////////////////////////////////////////////////////////////
// SHORTCUTS

var rsa = forge.pki.rsa;
var pki = forge.pki;

var hexToBytes = forge.util.hexToBytes;
var bytesToHex = forge.util.bytesToHex;

//////////////////////////////////////////////////////////////////////////
// UTILS

function int32ToHexString(integer) {
    var b = forge.util.createBuffer();
    b.putInt32(integer);
    return b.toHex()
}

function hexStringToInt(hexstring) {
    return parseInt(hexstring, 16);
}


// Concatenate hex encoded messages
function concatenate(a, b) {
    var a_length =  int32ToHexString(a.length/2);
    return a_length + a + b;
}

// Deconcatenate hex encoded messages
function deconcatenate(message) {
    var splitpos = 2*hexStringToInt(message.slice(null, 8));
    var a = message.slice(8, splitpos+8);
    var b = message.slice(splitpos+8);
    return {first:a, second:b};
}

function splitter(message) {
    var bytes = forge.util.createBuffer(hexToBytes(message));

    function empty() {
        return bytes.length()==0;
    }

    function nextMessage() {
        if (empty()) 
            throw new Error('Empty message');
        var n = bytes.getInt32();
        return bytesToHex(bytes.getBytes(n));
    }

    return {empty:empty, nextMessage:nextMessage};
}

exports.hexStringToInt = hexStringToInt;
exports.int32ToHexString = int32ToHexString;
exports.concatenate = concatenate;
exports.deconcatenate = deconcatenate;
exports.splitter = splitter;


//////////////////////////////////////////////////////////////////////////
// HASHES

// Returns SHA1-digest (160 bits) of an utf8 stsring
//
exports.hashUTF8 = function hashUTF8(sting) {
    var md = forge.md.sha1.create()
    md.update(string, 'utf8');
    return md.digest().toHex();
}

// Returns SHA1-digest (160 bits) of a hex-encoded message
//
exports.hash = function hash(message) {
    var md = forge.md.sha1.create()
    md.update(message);
    return md.digest().toHex();
}

//////////////////////////////////////////////////////////////////////////
// RANDOM

// Returns a random string of length bytes.
// By default, length==20 bytes (160-bit).
//
function nonce(length) {
    if(!length) length = 20;
    return bytesToHex(forge.random.getBytesSync(length));
}

exports.nonce = nonce;

//////////////////////////////////////////////////////////////////////////
// SYMMETRIC KEY AUTHENTICATED ENCRYPTION

// Public key encryption 
// (AES in GCM mode with 96-bit random IV)
//
function symenc(key, message, iv) {
    key = hexToBytes(key);
    message = hexToBytes(message);
    if (iv) 
        iv = hexToBytes(iv);
    else
        iv = forge.random.getBytesSync(12); // take a random iv

    var cipher = forge.cipher.createCipher('AES-GCM', key);
    cipher.start({
      iv: iv, // should be a 12-byte binary-encoded string or byte buffer
      tagLength: 128 // optional, defaults to 128 bits
    });
    cipher.update(forge.util.createBuffer(message));
    cipher.finish();
    var enc = cipher.output;
    var tag = cipher.mode.tag; // authentication tag

    // the result ciphertext =  iv | enc | tag
    var c = forge.util.createBuffer();
    c.putBytes(iv);
    c.putBytes(enc.data);
    c.putBytes(tag.data);
    return c.toHex();
}


// Decryption
// (AES in GCM mode with 96-bit random IV)
//
function symdec(key, ciphertext) {
    key = hexToBytes(key);
    ciphertext = forge.util.createBuffer(hexToBytes(ciphertext));

    // split the ciphertext into iv, enc, and tag:
    var iv =  ciphertext.getBytes(12);
    var enc = ciphertext.getBytes(ciphertext.length() - 16);
    var tag = ciphertext.getBytes();

    var decipher = forge.cipher.createDecipher('AES-GCM', key);
    decipher.start({
      iv: iv,
      tagLength: 128, // optional, defaults to 128 bits
      tag: tag // authentication tag from encryption
    });
    decipher.update(forge.util.createBuffer(enc));
    var pass = decipher.finish();
    if(pass) { // decryption succeeded
        return decipher.output.toHex();
    }
    else // decryption failure
        return null;
}

// Key generation for symmetric encryption.
// A key is simply a hex-formated random 32-byte string
//
function symkeygen() {
    return bytesToHex(forge.random.getBytesSync(32));
}

exports.symkeygen = symkeygen;
exports.symenc = symenc;
exports.symdec = symdec;

//////////////////////////////////////////////////////////////////////////
// PUBLIC KEY ENCRYPTION 

// Private key encoding/decoding (to/from hex) - PKCS#8
//
function privateKeyToHex(privateKey) {
    return bytesToHex(forge.asn1.toDer(pki.privateKeyToAsn1(privateKey)).getBytes());
}
function hexToPrivateKey(hexPrivateKey) {
    return pki.privateKeyFromAsn1(forge.asn1.fromDer(hexToBytes(hexPrivateKey)));
}

exports.privateKeyToHex = privateKeyToHex;
exports.hexToPrivateKey = hexToPrivateKey;

// Public key encoding/decoding (to/from hex) - X.509
//
function publicKeyToHex(publicKey) {
    return bytesToHex(forge.asn1.toDer(pki.publicKeyToAsn1(publicKey)).getBytes());
}
function hexToPublicKey(hexPublicKey) {
    return pki.publicKeyFromAsn1(forge.asn1.fromDer(hexToBytes(hexPublicKey)));
}

exports.publicKeyToHex = publicKeyToHex;
exports.hexToPublicKey = hexToPublicKey;

// Generates RSA public key pair
function rsa_keygen(length) {
    if (!length) length = 1024;
    keypair = rsa.generateKeyPair({bits: length});
    return { encryptionKey : publicKeyToHex(keypair.publicKey),  
             decryptionKey : privateKeyToHex(keypair.privateKey) };
}

// Public key encryption.
// Uses RSAES-OAEP/SHA-256/MGF1-SHA-256
// Parameter 'randomness' may be undefined. In this case a random
// 32-byte string will be generated for it.
function rsa_encrypt(publicKey, message, randomness) {
    var pk = hexToPublicKey(publicKey);
    return bytesToHex(pk.encrypt(hexToBytes(message), 'RSA-OAEP', {
                            md: forge.md.sha256.create(),
                            mgf1: { md: forge.md.sha256.create() },
                            seed: randomness
                         }));
}

// Public key decryption.
// Uses RSAES-OAEP/SHA-256/MGF1-SHA-256
//
function rsa_decrypt(privateKey, ciphertext) {
    var sk = hexToPrivateKey(privateKey);
    return bytesToHex(sk.decrypt(hexToBytes(ciphertext), 'RSA-OAEP', {
                            md: forge.md.sha256.create(),
                            mgf1: { md: forge.md.sha256.create() }
                         }));
}

exports.rsa_keygen = rsa_keygen;
exports.rsa_encrypt = rsa_encrypt;
exports.rsa_decrypt = rsa_decrypt;

//////////////////////////////////////////////////////////////////////////
// PUBLIC-KEY HYBRID ENCRYPTION


// Public-key hybrid key generation
//
exports.pke_keygen = exports.rsa_keygen;


// Public-key hybrid key encrytpion
//
exports.pke_encrypt = function pke_encrypt(encryptionKey, message, randomCoins) {
    var key, rsaRand, iv; 

    if (randomCoins) {
        key = randomCoins.symKey;
        rsaRand = randomCoins.rsaRand;
        iv = randomCoins.iv;
    }
    else {
        key = symkeygen();
        rsaRand = null;
        iv = null;
    }

    var encryptedKey = rsa_encrypt(encryptionKey, key, rsaRand);
    var encryptedMessage = symenc(key, message, iv)
    return concatenate(encryptedKey, encryptedMessage);
}


// Public-key hybrid key decryption
//
exports.pke_decrypt = function pke_decrypt(decryptionKey, message) {
    var m = deconcatenate(message);
    var key = rsa_decrypt(decryptionKey, m.first);
    return symdec(key, m.second);
}

// Generates random coins for public-key (hybrid) encryption.
function pke_generateEncryprionCoins() {
    return { rsaRand : nonce(16),
             symKey  : symkeygen(),
             iv      : nonce(12)
           };
}


//////////////////////////////////////////////////////////////////////////
// DIGITAL SIGNATURES

// Generates a signing/verification key pair
function sig_keygen() {
    var length = 1024;
    keypair = rsa.generateKeyPair({bits: length});
    return { verificationKey : publicKeyToHex(keypair.publicKey),  
             signingKey : privateKeyToHex(keypair.privateKey) };
}

var saltLength = 32;

// Create a digital signature for a message
function sign(signingKey, message) {
    var md = forge.md.sha256.create();
    md.update(hexToBytes(message));
    var privateKey = hexToPrivateKey(signingKey);
    var pss = forge.pss.create({
                md: forge.md.sha256.create(),
                mgf: forge.mgf.mgf1.create(forge.md.sha256.create()),
                saltLength: saltLength
                });
    var signature = privateKey.sign(md, pss);
    return bytesToHex(signature);
}

// Verifies a digital signature for a message
function verifsig(verificationKey, message, signature) {
    try {
        signature = hexToBytes(signature);
        var md = forge.md.sha256.create();
        md.update(hexToBytes(message));
        var publicKey = hexToPublicKey(verificationKey)
        var pss = forge.pss.create({
                    md: forge.md.sha256.create(),
                    mgf: forge.mgf.mgf1.create(forge.md.sha256.create()),
                    saltLength: saltLength
                    });
        return publicKey.verify(md.digest().bytes(), signature, pss);
    }
    catch (err) {
        return false;
    }
}

exports.sig_keygen = sig_keygen;
exports.sign = sign;
exports.verifsig = verifsig;
exports.pke_generateEncryprionCoins = pke_generateEncryprionCoins;

//////////////////////////////////////////////////////////////////////////////////////////////
return exports;
}();

if (typeof(module)!=='undefined' && module.exports) {
    module.exports = cryptofunc;
}
